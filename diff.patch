diff --git a/kernel/kernel.c b/kernel/kernel.c
index cc073c3..0038604 100644
--- a/kernel/kernel.c
+++ b/kernel/kernel.c
@@ -44,7 +44,11 @@ void start_kernel(uint32_t *sysmbstruct, uint32_t mbmagic, uint32_t *heap_top)
 	//square_pit(1);
 	 while (1) {
 		wait(1000);
-		printk("Timer ended\n");
+		printk("foo");
+		if (kmalloc(0x100000))
+			printk("Timer ended\n");
+		else
+			printk("Out of memory\n");
 	}
 
 	while(1)
diff --git a/kernel/mm.c b/kernel/mm.c
index 9af624b..6b3a47a 100644
--- a/kernel/mm.c
+++ b/kernel/mm.c
@@ -15,6 +15,7 @@
 #include <kernel/klib.h>
 
 extern void *kernel_heap;
+extern char *kernelpagedir;
 extern uint32_t *mbstruct;
 extern struct proc_struct *kernel_thread;
 
@@ -37,34 +38,96 @@ void init_heap(void *heap_base)
 	first_block->next = NULL;
 }
 
-void add_heap(void *heap_base)
+int expand_heap(void *heap_base)
 {
-	
+	/* TODO: Separate x86-specific logic to x86/paging.c */
+	/* TODO: Consider errors in physical page allocation. */
+
+	/* Get current heap limit */
+	struct bh *last = (struct bh *)heap_base;
+	while (last->next != NULL) {
+		last = last->next;
+	}
+	size_t heap_limit = (size_t)last + last->size + HEADER_SIZE;
+
+	uint32_t pde_index = heap_limit / 0x400000;
+	uint32_t pte_index = (heap_limit % 0x400000) / 0x1000;
+	uint32_t *pd_virt = (uint32_t *)(&kernelpagedir + 0xc0000000);
+	uint32_t *pt_virt;
+	uint32_t pt_phys;
+	if ((pd_virt[pde_index] & 0x1) == 0) {
+		struct page_struct *pte = page_alloc(1);
+		pd_virt[pde_index] = pte->phys_addr;
+		pd_virt[pde_index] = pd_virt[pde_index] | 0x3;
+		pt_phys = pte->phys_addr; /* This ain't virtual address, it is phsycal address. */
+	} else {
+		pt_phys = pd_virt[pde_index] & 0xFFFFF000; /* Same as above. */
+	}
+
+	/*
+	   Chicken or egg. Need to page in pt in order to page in new page of
+	   heap.
+	   Need to quickly map pt, write to it, and then unmap it.
+	*/
+	pd_virt[1023] = pt_phys / 0x00400000;
+	pd_virt[1023] = pd_virt[1023] | 0x83;
+	pt_virt = (uint32_t *)((pt_phys % 0x00400000) | 0xFFC00000);
+
+	struct page_struct *new_page = page_alloc(1);
+	pt_virt[pte_index] = new_page->phys_addr; /* page fault on this line. */
+	pt_virt[pte_index] = pt_virt[pte_index] | 0x3;
+	pd_virt[1023] = 0x0;
+	printk("Should have new page\n");
+
+	if (last->size % 2) {
+		panic("not done");
+	} else {
+		last->size += 0x1000;
+		/*uint32_t beef = 0xDEADBEEF;
+		uint32_t *foo = (uint32_t *)heap_limit;
+		uint32_t beefw = 0xDEADBEEF;
+		*foo = beef;
+		*foo = beefw;
+		uint32_t bef0 = 0xDEADBEEF + 1;
+		foo[1] = bef0;
+		__asm__("cli;hlt;");*/
+	}
+
+	return 1;
 }
 
 void *alloc_free(size_t demand_size, void *heap_base)
 {
 	struct bh *current = (struct bh *)heap_base;
+	printaddr((int)heap_base);
 	struct bh *old_next = current->next;
 
 	size_t alloc_size = demand_size + (demand_size % 2);
 	size_t alloc_size_w_bh = alloc_size + HEADER_SIZE;
 
+SEARCH:
 	do {
-		if (current->size == alloc_size)
+		if (current->size == alloc_size) {
 			goto FOUND_EXACT;
-		else if (current->size >= alloc_size_w_bh\
-					&& current->size % 2 == 0)
+		} else if (current->size >= alloc_size_w_bh\
+					&& current->size % 2 == 0) {
 			goto FOUND_GREATER;
-		else if (current->next == NULL)
+		} else if (current->next == NULL) {
 			goto FAIL;
-		else 
+		} else {
 			current = current->next;
+			old_next = old_next->next;
+		}
 
 	} while(true);
 
 FAIL:
-	return NULL;
+	if (expand_heap(heap_base)) {
+		goto SEARCH;
+	} else {
+		/* If efforts above are in vain... */
+		return NULL;
+	}
 
 FOUND_EXACT:
 	current->size = current->size - 1;
@@ -76,8 +139,9 @@ FOUND_GREATER:
 	if (!old_next)
 		current->next->next = NULL;
 	else
-		current->next->next = old_next;
+		current->next->next = current->next;
 
+	/* returns 0x0 ...wtf? */
 	return (char *)current + HEADER_SIZE;
 
 	/* Mysteriously, execution ended up here... */
diff --git a/kernel/page_alloc.c b/kernel/page_alloc.c
index a077e40..8e76a43 100644
--- a/kernel/page_alloc.c
+++ b/kernel/page_alloc.c
@@ -4,6 +4,7 @@
  */
 #include <stdint.h>
 #include <stdbool.h>
+#include <stddef.h>
 
 #include <kernel/page_alloc.h> 
 #include <kernel/panic.h>
@@ -12,8 +13,7 @@
 extern uint32_t kernelpagedir;
 extern uint32_t *mbstruct;
 
-struct mem_region
-{
+struct mem_region {
 	uint32_t size;
 	uint64_t base_addr;
 	uint64_t length;
@@ -25,7 +25,8 @@ static struct page_struct *ps;
 
 static uint32_t mmap_length;
 
-void probe_pages(){
+void probe_pages()
+{
 	mmap_length = mbstruct[11];
 	mmap_addr = (struct mem_region *)(mbstruct[12] + 0xc0000000);
 
@@ -38,40 +39,55 @@ void probe_pages(){
 	ps = (struct page_struct *)kmalloc(sizeof(struct page_struct) *\
 		    max_pages);
 	
+	printaddr((int)ps);
+	printk("\n");
 	if (ps) {
 		for (int i = 0; i < max_pages; i++) {
 			ps[i].phys_addr = 0x1000 * i;
 			ps[i].flags = 0x2; /* kernel, non-mapped */
-			ps[i].next = (struct page_struct *)(0x1000 * (i + 1));
+			ps[i].next = (struct page_struct *)(&ps[i + 1]);
+			if (i % 16 == 0) {
+				//printaddr((int)&ps[i]);
+				//printk("\n");
+			}
 		}
+		printk("done");
 	} else
 		panic("Failed to allocate memory for page structs");
+	__asm__("cli;");
+	__asm__("hlt;");
 	ps[max_pages - 1].next = NULL;
 
 	/* Assuming first three 4MiB pages are allocated at boot. */
 	for (int i = 0; i < 0xc00; i++)
 		ps[i].flags = 0x3; /* kernel, mapped */
 
-	/* Detect IO mapped memory regions and flag them as so */
-	
+	/* Assume ISA memory hole */
+	for (int i = 0xf00; i < 0x1000; i++)
+		ps[i].flags = 0x6; /* kernel, non-mapped, io-mapped */
 }
 
-struct page_struct * page_alloc_free(size_t contiguous)
+struct page_struct * page_alloc(size_t contiguous)
 {
-	int fp;
-	for (fp = 0; ps[fp].next != NULL; fp++) {
-		if ((ps[fp].flags & 0x1) == 0x1) {
-			bool is_sufficient = true;
-			for (int j = fp + 1; j < fp + contiguous; fp++) {
-				if ((ps[fp].flags & 0x1) != 0x1) {
-					is_sufficient = false;
-					break;
-				}
-			}
-			if (is_sufficient)
-				goto FOUND;
+	int fp = 0;
+	bool fp_set = false;
+	bool sufficient;
+
+	/* first fit allocation */
+	for (int i = 0; ps[i].next != NULL; i++) {
+		if ((ps[i].flags & 0x5) == 0 && !fp_set) {
+			fp = i;
+			fp_set = true;
+		}
+		if (i - fp >= contiguous) {
+			sufficient = true;
+			break;
 		}
 	}
+
+	if (sufficient)
+		goto FOUND;
+
 	return NULL;
 FOUND:
 	for (int i = 0; i < contiguous; i++) {
@@ -80,4 +96,10 @@ FOUND:
 	return (ps + fp);
 }
 
+
+void page_free(struct page_struct *page)
+{
+	page->flags = page->flags & 0x6;
+}
+
 /* TODO: Ensure safety of multiboot data structure */
diff --git a/kernel/x86/interrupts.c b/kernel/x86/interrupts.c
index 8c8cdd0..02b9c00 100644
--- a/kernel/x86/interrupts.c
+++ b/kernel/x86/interrupts.c
@@ -60,8 +60,7 @@ void set_idt()
 	idt[0x22] = INTERRUPT(0x8, (uint32_t)&apic_timer_irq, 0x4);
 	static struct idt_ptr sysidt;
 	sysidt.base = (uint32_t)&idt;
-	sysidt.limit = (uint16_t)sizeof(idt);
-
+	sysidt.limit = (uint16_t)sizeof(idt); 
 	__asm__(
 	"lidtl %0;"
 	:
@@ -76,5 +75,5 @@ void divzero()
 
 void double_fault_panic()
 {
-	__asm__("cli;hlt");;
+	__asm__("cli;hlt;");;
 }
diff --git a/kernel/x86/paging.c b/kernel/x86/paging.c
index da44d2d..9a495ab 100644
--- a/kernel/x86/paging.c
+++ b/kernel/x86/paging.c
@@ -3,3 +3,4 @@
  *  Stuff about x86 paging.
  *  REMINDER: kmalloc is not x86 specific, paging is.
  */
+
diff --git a/path.sh b/path.sh
old mode 100644
new mode 100755
diff --git a/sysroot/usr/include/kernel/page_alloc.h b/sysroot/usr/include/kernel/page_alloc.h
index a399efa..f41f26f 100644
--- a/sysroot/usr/include/kernel/page_alloc.h
+++ b/sysroot/usr/include/kernel/page_alloc.h
@@ -3,6 +3,7 @@
 
 #include <stdint.h>
 #include <stdbool.h>
+#include <stddef.h>
 
 struct page_struct;
 
@@ -21,6 +22,6 @@ struct page_struct {
 
 void probe_pages();
 
-struct page_struct * page_rq(); 
+struct page_struct * page_alloc(size_t contiguous); 
 
 #endif
